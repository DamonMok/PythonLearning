
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <title>内存管理 &#8212; Python 3.8.4rc1 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.8.4rc1 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="对象实现支持" href="objimpl.html" />
    <link rel="prev" title="Python初始化配置" href="init_config.html" />
    <link rel="canonical" href="https://docs.python.org/3/c-api/memory.html" />
    
      
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     


  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="对象实现支持"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="Python初始化配置"
             accesskey="P">上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.4rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python/C API 参考手册</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="memory-management">
<span id="memory"></span><h1>内存管理<a class="headerlink" href="#memory-management" title="永久链接至标题">¶</a></h1>
<div class="section" id="overview">
<span id="memoryoverview"></span><h2>概述<a class="headerlink" href="#overview" title="永久链接至标题">¶</a></h2>
<p>在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有堆的管理由内部的 <em>Python 内存管理器（Python memory manager）</em> 保证。Python 内存管理器有不同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。</p>
<p>在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空间来存储所有与 Python 相关的数据。在原始内存分配器的基础上，几个对象特定的分配器在同一堆上运行，并根据每种对象类型的特点实现不同的内存管理策略。例如，整数对象在堆内的管理方式不同于字符串、元组或字典，因为整数需要不同的存储需求和速度与空间的权衡。因此，Python 内存管理器将一些工作分配给对象特定分配器，但确保后者在私有堆的范围内运行。</p>
<p>Python 堆内存的管理是由解释器来执行，用户对它没有控制权，即使他们经常操作指向堆内内存块的对象指针，理解这一点十分重要。Python 对象和其他内部缓冲区的堆空间分配是由 Python 内存管理器按需通过本文档中列出的 Python/C API 函数进行的。</p>
<p id="index-0">为了避免内存破坏，扩展的作者永远不应该试图用 C 库函数导出的函数来对 Python 对象进行操作，这些函数包括： <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>。这将导致 C 分配器和 Python 内存管理器之间的混用，引发严重后果，这是由于它们实现了不同的算法，并在不同的堆上操作。但是，我们可以安全地使用 C 库分配器为单独的目的分配和释放内存块，如下例所示：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="p">...</span><span class="n">Do</span> <span class="n">some</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operation</span> <span class="n">involving</span> <span class="n">buf</span><span class="p">...</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* malloc&#39;ed */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>在这个例子中，I/O 缓冲区的内存请求是由 C 库分配器处理的。Python 内存管理器只参与了分配作为结果返回的字节对象。</p>
<p>然而，在大多数情况下，建议专门从 Python 堆中分配内存，因为后者由 Python 内存管理器控制。例如，当解释器扩展了用 C 写的新对象类型时，就必须这样做。使用 Python 堆的另一个原因是希望*通知* Python 内存管理器关于扩展模块的内存需求。即使所请求的内存全部只用于内部的、高度特定的目的，将所有的内存请求交给 Python 内存管理器能让解释器对其内存占用的整体情况有更准确的了解。因此，在某些情况下，Python 内存管理器可能会触发或不触发适当的操作，如垃圾回收、内存压缩或其他预防性操作。请注意，通过使用前面例子中所示的 C 库分配器，为 I/O 缓冲区分配的内存会完全不受 Python 内存管理器管理。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>环境变量 <span class="target" id="index-7"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> 可被用来配置 Python 所使用的内存分配器。</p>
<p>环境变量 <span class="target" id="index-8"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOCSTATS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOCSTATS</span></code></a> 可以用来在每次创建和关闭新的 pymalloc 对象区域时打印 <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc  内存分配器</span></a> 的统计数据。</p>
</div>
</div>
<div class="section" id="raw-memory-interface">
<h2>原始内存接口<a class="headerlink" href="#raw-memory-interface" title="永久链接至标题">¶</a></h2>
<p>以下函数集封装了系统分配器。这些函数是线程安全的，不需要持有 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a>。</p>
<p><a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default raw memory allocator</span></a> 使用这些函数：<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>、 <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>、 <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>；申请零字节时则调用 <code class="docutils literal notranslate"><span class="pre">malloc(1)``（或</span> <span class="pre">``calloc(1,</span> <span class="pre">1)</span></code>）</p>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<dl class="function">
<dt id="c.PyMem_RawMalloc">
void* <code class="sig-name descname">PyMem_RawMalloc</code><span class="sig-paren">(</span>size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawMalloc" title="永久链接至目标">¶</a></dt>
<dd><p>分配 <em>n</em> 个字节，并返回一个指向分配的内存的 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 类型指针，如果请求失败，则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了``PyMem_RawMalloc(1)`` 一样。但是内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawCalloc">
void* <code class="sig-name descname">PyMem_RawCalloc</code><span class="sig-paren">(</span>size_t<em> nelem</em>, size_t<em> elsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawCalloc" title="永久链接至目标">¶</a></dt>
<dd><p>分配 <em>nelem</em> 个元素，每个元素的大小为 <em>elsize</em> 字节，并返回指向分配的内存的 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*/</span></code> 类型指针，如果请求失败，则返回``NULL``。内存被初始化为零。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了``PyMem_RawCalloc(1, 1)`` 一样。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawRealloc">
void* <code class="sig-name descname">PyMem_RawRealloc</code><span class="sig-paren">(</span>void<em> *p</em>, size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawRealloc" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>p</em> 指向的内存块大小调整为 <em>n</em> 字节。以新旧内存块大小中的最小值为准，其中内容保持不变，</p>
<p>如果*p*是``NULL``，则相当于调用 <code class="docutils literal notranslate"><span class="pre">PyMem_RawMalloc(n)</span></code> ；如果 <em>n</em> 等于 0，则内存块大小会被调整，但不会被释放，返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a> 所返回的。</p>
<p>如果请求失败，<a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <em>p</em> 仍然是指向先前内存区域的有效指针。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_RawFree">
void <code class="sig-name descname">PyMem_RawFree</code><span class="sig-paren">(</span>void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawFree" title="永久链接至目标">¶</a></dt>
<dd><p>释放 <em>p</em> 指向的内存块。除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a> 所返回的指针。否则，或在 <code class="docutils literal notranslate"><span class="pre">PyMem_RawFree(p)</span></code> 之前已经调用过的情况下，未定义的行为会发生。</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 那么什么操作也不会进行。</p>
</dd></dl>

</div>
<div class="section" id="memory-interface">
<span id="memoryinterface"></span><h2>内存接口<a class="headerlink" href="#memory-interface" title="永久链接至标题">¶</a></h2>
<p>以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内存。</p>
<p><a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">默认内存分配器</span></a> 使用了 <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc 内存分配器</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在使用这些函数时，必须持有 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">全局解释器锁（GIL）</span></a> 。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>现在默认的分配器是 pymalloc 而非系统的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 。</p>
</div>
<dl class="function">
<dt id="c.PyMem_Malloc">
void* <code class="sig-name descname">PyMem_Malloc</code><span class="sig-paren">(</span>size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Malloc" title="永久链接至目标">¶</a></dt>
<dd><p>分配 <em>n</em> 个字节，并返回一个指向分配的内存的 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 类型指针，如果请求失败，则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了``PyMem_Malloc(1)`` 一样。但是内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Calloc">
void* <code class="sig-name descname">PyMem_Calloc</code><span class="sig-paren">(</span>size_t<em> nelem</em>, size_t<em> elsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Calloc" title="永久链接至目标">¶</a></dt>
<dd><p>分配 <em>nelem</em> 个元素，每个元素的大小为 <em>elsize</em> 字节，并返回指向分配的内存的 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*/</span></code> 类型指针，如果请求失败，则返回``NULL``。内存被初始化为零。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了``PyMem_Calloc(1, 1)`` 一样。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Realloc">
void* <code class="sig-name descname">PyMem_Realloc</code><span class="sig-paren">(</span>void<em> *p</em>, size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Realloc" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>p</em> 指向的内存块大小调整为 <em>n</em> 字节。以新旧内存块大小中的最小值为准，其中内容保持不变，</p>
<p>如果*p*是``NULL``，则相当于调用 <code class="docutils literal notranslate"><span class="pre">PyMem_Malloc(n)</span></code> ；如果 <em>n</em> 等于 0，则内存块大小会被调整，但不会被释放，返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a> 所返回的。</p>
<p>如果请求失败，<a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <em>p</em> 仍然是指向先前内存区域的有效指针。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Free">
void <code class="sig-name descname">PyMem_Free</code><span class="sig-paren">(</span>void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Free" title="永久链接至目标">¶</a></dt>
<dd><p>释放 <em>p</em> 指向的内存块。除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a> 所返回的指针。否则，或在 <code class="docutils literal notranslate"><span class="pre">PyMem_Free(p)</span></code> 之前已经调用过的情况下，未定义的行为会发生。</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 那么什么操作也不会进行。</p>
</dd></dl>

<p>以下面向类型的宏为方便而提供。 注意 <em>TYPE</em> 可以指任何 C 类型。</p>
<dl class="function">
<dt id="c.PyMem_New">
TYPE* <code class="sig-name descname">PyMem_New</code><span class="sig-paren">(</span>TYPE, size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_New" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 相同，但分配 <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> 字节的内存。返回一个转换为 <code class="xref c c-type docutils literal notranslate"><span class="pre">TYPE*</span></code> 的指针。内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Resize">
TYPE* <code class="sig-name descname">PyMem_Resize</code><span class="sig-paren">(</span>void<em> *p</em>, TYPE, size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Resize" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 相同，但内存块的大小被调整为 <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> 字节。返回一个转换为 <code class="xref c c-type docutils literal notranslate"><span class="pre">TYPE|*</span></code> 类型的指针。返回时， <em>p</em> 是指向新内存区域的指针；如果失败，则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>这是一个 C 预处理宏， <em>p</em> 总是被重新赋值。请保存 <em>p</em> 的原始值，以避免在处理错误时丢失内存。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_Del">
void <code class="sig-name descname">PyMem_Del</code><span class="sig-paren">(</span>void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Del" title="永久链接至目标">¶</a></dt>
<dd><p>与 <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> 相同</p>
</dd></dl>

<p>此外，我们还提供了以下宏集用于直接调用 Python 内存分配器，而不涉及上面列出的 C API 函数。但是请注意，使用它们并不能保证跨 Python 版本的二进制兼容性，因此在扩展模块被弃用。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_MALLOC(size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_NEW(type,</span> <span class="pre">size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_REALLOC(ptr,</span> <span class="pre">size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_RESIZE(ptr,</span> <span class="pre">type,</span> <span class="pre">size)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_FREE(ptr)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PyMem_DEL(ptr)</span></code></p></li>
</ul>
</div>
<div class="section" id="object-allocators">
<h2>对象分配器<a class="headerlink" href="#object-allocators" title="永久链接至标题">¶</a></h2>
<p>以下函数集，仿照 ANSI C 标准，并指定了请求零字节时的行为，可用于从Python堆分配和释放内存。</p>
<p><a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">默认对象分配器</span></a> 使用 <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc 内存分配器</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>在使用这些函数时，必须持有 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">全局解释器锁（GIL）</span></a> 。</p>
</div>
<dl class="function">
<dt id="c.PyObject_Malloc">
void* <code class="sig-name descname">PyObject_Malloc</code><span class="sig-paren">(</span>size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Malloc" title="永久链接至目标">¶</a></dt>
<dd><p>分配 <em>n</em> 个字节，并返回一个指向分配的内存的 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*</span></code> 类型指针，如果请求失败，则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了``PyObject_Malloc(1)`` 一样。但是内存不会以任何方式被初始化。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Calloc">
void* <code class="sig-name descname">PyObject_Calloc</code><span class="sig-paren">(</span>size_t<em> nelem</em>, size_t<em> elsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Calloc" title="永久链接至目标">¶</a></dt>
<dd><p>分配 <em>nelem</em> 个元素，每个元素的大小为 <em>elsize</em> 字节，并返回指向分配的内存的 <code class="xref c c-type docutils literal notranslate"><span class="pre">void*/</span></code> 类型指针，如果请求失败，则返回``NULL``。内存被初始化为零。</p>
<p>请求零字节可能返回一个独特的非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，就像调用了``PyObject_Calloc(1, 1)`` 一样。</p>
<div class="versionadded">
<p><span class="versionmodified added">3.5 新版功能.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Realloc">
void* <code class="sig-name descname">PyObject_Realloc</code><span class="sig-paren">(</span>void<em> *p</em>, size_t<em> n</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Realloc" title="永久链接至目标">¶</a></dt>
<dd><p>将 <em>p</em> 指向的内存块大小调整为 <em>n</em> 字节。以新旧内存块大小中的最小值为准，其中内容保持不变，</p>
<p>如果*p*是``NULL``，则相当于调用 <code class="docutils literal notranslate"><span class="pre">PyObject_Malloc(n)</span></code> ；如果 <em>n</em> 等于 0，则内存块大小会被调整，但不会被释放，返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。</p>
<p>除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a> 所返回的。</p>
<p>如果请求失败，<a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ， <em>p</em> 仍然是指向先前内存区域的有效指针。</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_Free">
void <code class="sig-name descname">PyObject_Free</code><span class="sig-paren">(</span>void<em> *p</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Free" title="永久链接至目标">¶</a></dt>
<dd><p>释放 <em>p</em> 指向的内存块。除非 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> ，否则它必须是之前调用 <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> 、 <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 或 <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a> 所返回的指针。否则，或在 <code class="docutils literal notranslate"><span class="pre">PyObject_Free(p)</span></code> 之前已经调用过的情况下，未定义的行为会发生。</p>
<p>如果 <em>p</em> 是 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 那么什么操作也不会进行。</p>
</dd></dl>

</div>
<div class="section" id="default-memory-allocators">
<span id="id1"></span><h2>默认内存分配器<a class="headerlink" href="#default-memory-allocators" title="永久链接至标题">¶</a></h2>
<p>默认内存分配器：</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 18%" />
<col style="width: 16%" />
<col style="width: 19%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>配置</p></th>
<th class="head"><p>名称</p></th>
<th class="head"><p>PyMem_RawMalloc</p></th>
<th class="head"><p>PyMem_Malloc</p></th>
<th class="head"><p>PyObject_Malloc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>发布版本</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;pymalloc&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>调试构建</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;pymalloc_debug&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code> + debug</p></td>
</tr>
<tr class="row-even"><td><p>没有 pymalloc 的发布版本</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;malloc&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>没有 pymalloc 的调试构建</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">&quot;malloc_debug&quot;</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
</tr>
</tbody>
</table>
<p>说明：</p>
<ul class="simple">
<li><p>Name: value for <span class="target" id="index-3"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> environment variable</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code>: system allocators from the standard C library, C functions:
<code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code>: <a class="reference internal" href="#pymalloc"><span class="std std-ref">pymalloc memory allocator</span></a></p></li>
<li><p>&quot;+ debug&quot;: with debug hooks installed by <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a></p></li>
</ul>
</div>
<div class="section" id="customize-memory-allocators">
<h2>Customize Memory Allocators<a class="headerlink" href="#customize-memory-allocators" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<dl class="type">
<dt id="c.PyMemAllocatorEx">
<code class="sig-name descname">PyMemAllocatorEx</code><a class="headerlink" href="#c.PyMemAllocatorEx" title="永久链接至目标">¶</a></dt>
<dd><p>Structure used to describe a memory block allocator. The structure has
four fields:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>域</p></th>
<th class="head"><p>含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ctx</span></code></p></td>
<td><p>user context passed as first argument</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">malloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p>allocate a memory block</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">calloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">nelem,</span> <span class="pre">size_t</span> <span class="pre">elsize)</span></code></p></td>
<td><p>allocate a memory block initialized
with zeros</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">realloc(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">new_size)</span></code></p></td>
<td><p>allocate or resize a memory block</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></p></td>
<td><p>释放一个内存块</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.5 版更改: </span>The <code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocator</span></code> structure was renamed to
<a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocatorEx</span></code></a> and a new <code class="docutils literal notranslate"><span class="pre">calloc</span></code> field was added.</p>
</div>
</dd></dl>

<dl class="type">
<dt id="c.PyMemAllocatorDomain">
<code class="sig-name descname">PyMemAllocatorDomain</code><a class="headerlink" href="#c.PyMemAllocatorDomain" title="永久链接至目标">¶</a></dt>
<dd><p>Enum used to identify an allocator domain. Domains:</p>
<dl class="var">
<dt id="c.PYMEM_DOMAIN_RAW">
<code class="sig-name descname">PYMEM_DOMAIN_RAW</code><a class="headerlink" href="#c.PYMEM_DOMAIN_RAW" title="永久链接至目标">¶</a></dt>
<dd><p>函数</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</dd></dl>

<dl class="var">
<dt id="c.PYMEM_DOMAIN_MEM">
<code class="sig-name descname">PYMEM_DOMAIN_MEM</code><a class="headerlink" href="#c.PYMEM_DOMAIN_MEM" title="永久链接至目标">¶</a></dt>
<dd><p>函数</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>,</p></li>
<li><p><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a></p></li>
</ul>
</dd></dl>

<dl class="var">
<dt id="c.PYMEM_DOMAIN_OBJ">
<code class="sig-name descname">PYMEM_DOMAIN_OBJ</code><a class="headerlink" href="#c.PYMEM_DOMAIN_OBJ" title="永久链接至目标">¶</a></dt>
<dd><p>函数</p>
<ul class="simple">
<li><p><a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a></p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="c.PyMem_GetAllocator">
void <code class="sig-name descname">PyMem_GetAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain">PyMemAllocatorDomain</a><em> domain</em>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx">PyMemAllocatorEx</a><em> *allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_GetAllocator" title="永久链接至目标">¶</a></dt>
<dd><p>Get the memory block allocator of the specified domain.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_SetAllocator">
void <code class="sig-name descname">PyMem_SetAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain">PyMemAllocatorDomain</a><em> domain</em>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx">PyMemAllocatorEx</a><em> *allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetAllocator" title="永久链接至目标">¶</a></dt>
<dd><p>Set the memory block allocator of the specified domain.</p>
<p>The new allocator must return a distinct non-<code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer when requesting
zero bytes.</p>
<p>For the <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_RAW</span></code></a> domain, the allocator must be
thread-safe: the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> is not held when the
allocator is called.</p>
<p>If the new allocator is not a hook (does not call the previous allocator),
the <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> function must be called to reinstall the
debug hooks on top on the new allocator.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyMem_SetupDebugHooks">
void <code class="sig-name descname">PyMem_SetupDebugHooks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetupDebugHooks" title="永久链接至目标">¶</a></dt>
<dd><p>Setup hooks to detect bugs in the Python memory allocator functions.</p>
<p>Newly allocated memory is filled with the byte <code class="docutils literal notranslate"><span class="pre">0xCD</span></code> (<code class="docutils literal notranslate"><span class="pre">CLEANBYTE</span></code>),
freed memory is filled with the byte <code class="docutils literal notranslate"><span class="pre">0xDD</span></code> (<code class="docutils literal notranslate"><span class="pre">DEADBYTE</span></code>). Memory blocks
are surrounded by &quot;forbidden bytes&quot; (<code class="docutils literal notranslate"><span class="pre">FORBIDDENBYTE</span></code>: byte <code class="docutils literal notranslate"><span class="pre">0xFD</span></code>).</p>
<p>Runtime checks:</p>
<ul class="simple">
<li><p>Detect API violations, ex: <a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a> called on a buffer
allocated by <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a></p></li>
<li><p>Detect write before the start of the buffer (buffer underflow)</p></li>
<li><p>Detect write after the end of the buffer (buffer overflow)</p></li>
<li><p>Check that the <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">GIL</span></a> is held when
allocator functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (ex:
<a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>) and <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (ex:
<a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>) domains are called</p></li>
</ul>
<p>On error, the debug hooks use the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> module to get the
traceback where a memory block was allocated. The traceback is only
displayed if <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> is tracing Python memory allocations and the
memory block was traced.</p>
<p>These hooks are <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">installed by default</span></a> if
Python is compiled in debug
mode. The <span class="target" id="index-4"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> environment variable can be used to install
debug hooks on a Python compiled in release mode.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版更改: </span>This function now also works on Python compiled in release mode.
On error, the debug hooks now use <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> to get the traceback
where a memory block was allocated. The debug hooks now also check
if the GIL is held when functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> and
<a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> domains are called.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版更改: </span>Byte patterns <code class="docutils literal notranslate"><span class="pre">0xCB</span></code> (<code class="docutils literal notranslate"><span class="pre">CLEANBYTE</span></code>), <code class="docutils literal notranslate"><span class="pre">0xDB</span></code> (<code class="docutils literal notranslate"><span class="pre">DEADBYTE</span></code>) and
<code class="docutils literal notranslate"><span class="pre">0xFB</span></code> (<code class="docutils literal notranslate"><span class="pre">FORBIDDENBYTE</span></code>) have been replaced with <code class="docutils literal notranslate"><span class="pre">0xCD</span></code>, <code class="docutils literal notranslate"><span class="pre">0xDD</span></code>
and <code class="docutils literal notranslate"><span class="pre">0xFD</span></code> to use the same values than Windows CRT debug <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>
and <code class="docutils literal notranslate"><span class="pre">free()</span></code>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="the-pymalloc-allocator">
<span id="pymalloc"></span><h2>The pymalloc allocator<a class="headerlink" href="#the-pymalloc-allocator" title="永久链接至标题">¶</a></h2>
<p>Python has a <em>pymalloc</em> allocator optimized for small objects (smaller or equal
to 512 bytes) with a short lifetime. It uses memory mappings called &quot;arenas&quot;
with a fixed size of 256 KiB. It falls back to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> and
<a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> for allocations larger than 512 bytes.</p>
<p><em>pymalloc</em> is the <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default allocator</span></a> of the
<a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (ex: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>) and
<a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-data docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (ex: <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>) domains.</p>
<p>The arena allocator uses the following functions:</p>
<ul class="simple">
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">VirtualAlloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VirtualFree()</span></code> on Windows,</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">munmap()</span></code> if available,</p></li>
<li><p><code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> otherwise.</p></li>
</ul>
<div class="section" id="customize-pymalloc-arena-allocator">
<h3>Customize pymalloc Arena Allocator<a class="headerlink" href="#customize-pymalloc-arena-allocator" title="永久链接至标题">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">3.4 新版功能.</span></p>
</div>
<dl class="type">
<dt id="c.PyObjectArenaAllocator">
<code class="sig-name descname">PyObjectArenaAllocator</code><a class="headerlink" href="#c.PyObjectArenaAllocator" title="永久链接至目标">¶</a></dt>
<dd><p>Structure used to describe an arena allocator. The structure has
three fields:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 56%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>域</p></th>
<th class="head"><p>含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ctx</span></code></p></td>
<td><p>user context passed as first argument</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">alloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p>allocate an arena of size bytes</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></p></td>
<td><p>free an arena</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GetArenaAllocator">
<code class="sig-name descname">PyObject_GetArenaAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator">PyObjectArenaAllocator</a><em> *allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetArenaAllocator" title="永久链接至目标">¶</a></dt>
<dd><p>Get the arena allocator.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_SetArenaAllocator">
<code class="sig-name descname">PyObject_SetArenaAllocator</code><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator">PyObjectArenaAllocator</a><em> *allocator</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_SetArenaAllocator" title="永久链接至目标">¶</a></dt>
<dd><p>Set the arena allocator.</p>
</dd></dl>

</div>
</div>
<div class="section" id="tracemalloc-c-api">
<h2>tracemalloc C API<a class="headerlink" href="#tracemalloc-c-api" title="永久链接至标题">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">3.7 新版功能.</span></p>
</div>
<dl class="function">
<dt id="c.PyTraceMalloc_Track">
int <code class="sig-name descname">PyTraceMalloc_Track</code><span class="sig-paren">(</span>unsigned int<em> domain</em>, uintptr_t<em> ptr</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyTraceMalloc_Track" title="永久链接至目标">¶</a></dt>
<dd><p>Track an allocated memory block in the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> module.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">0</span></code> on success, return <code class="docutils literal notranslate"><span class="pre">-1</span></code> on error (failed to allocate memory to
store the trace). Return <code class="docutils literal notranslate"><span class="pre">-2</span></code> if tracemalloc is disabled.</p>
<p>If memory block is already tracked, update the existing trace.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyTraceMalloc_Untrack">
int <code class="sig-name descname">PyTraceMalloc_Untrack</code><span class="sig-paren">(</span>unsigned int<em> domain</em>, uintptr_t<em> ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyTraceMalloc_Untrack" title="永久链接至目标">¶</a></dt>
<dd><p>Untrack an allocated memory block in the <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> module.
Do nothing if the block was not tracked.</p>
<p>Return <code class="docutils literal notranslate"><span class="pre">-2</span></code> if tracemalloc is disabled, otherwise return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="memoryexamples"></span><h2>例子<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h2>
<p>Here is the example from section <a class="reference internal" href="#memoryoverview"><span class="std std-ref">概述</span></a>, rewritten so that the
I/O buffer is allocated from the Python heap by using the first function set:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* allocated with PyMem_Malloc */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>The same code using the type-oriented function set:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span> <span class="cm">/* for I/O */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="cm">/* allocated with PyMem_New */</span>
<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that in the two examples above, the buffer is always manipulated via
functions belonging to the same set. Indeed, it is required to use the same
memory API family for a given memory block, so that the risk of mixing different
allocators is reduced to a minimum. The following code sequence contains two
errors, one of which is labeled as <em>fatal</em> because it mixes two different
allocators operating on different heaps.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">buf1</span> <span class="o">=</span> <span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">buf3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span>  <span class="cm">/* Wrong -- should be PyMem_Free() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>       <span class="cm">/* Right -- allocated via malloc() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>       <span class="cm">/* Fatal -- should be PyMem_Del()  */</span>
</pre></div>
</div>
<p>In addition to the functions aimed at handling raw memory blocks from the Python
heap, objects in Python are allocated and released with <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_New()</span></code></a>,
<a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_NewVar()</span></code></a> and <a class="reference internal" href="allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>.</p>
<p>These will be explained in the next chapter on defining and implementing new
object types in C.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">内存管理</a><ul>
<li><a class="reference internal" href="#overview">概述</a></li>
<li><a class="reference internal" href="#raw-memory-interface">原始内存接口</a></li>
<li><a class="reference internal" href="#memory-interface">内存接口</a></li>
<li><a class="reference internal" href="#object-allocators">对象分配器</a></li>
<li><a class="reference internal" href="#default-memory-allocators">默认内存分配器</a></li>
<li><a class="reference internal" href="#customize-memory-allocators">Customize Memory Allocators</a></li>
<li><a class="reference internal" href="#the-pymalloc-allocator">The pymalloc allocator</a><ul>
<li><a class="reference internal" href="#customize-pymalloc-arena-allocator">Customize pymalloc Arena Allocator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tracemalloc-c-api">tracemalloc C API</a></li>
<li><a class="reference internal" href="#examples">例子</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="init_config.html"
                        title="上一章">Python初始化配置</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="objimpl.html"
                        title="下一章">对象实现支持</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">提交 Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.8/Doc/c-api/memory.rst"
            rel="nofollow">显示源代码
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="对象实现支持"
             >下一页</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="Python初始化配置"
             >上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

    <li>
      <a href="../index.html">3.8.4rc1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API 参考手册</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 2001-2020, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 7月 05, 2020.
    <a href="https://docs.python.org/3/bugs.html">Found a bug</a>?
    <br />

    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>

  </body>
</html>